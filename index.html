<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>KadamFit ¬∑ territory runner</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* (styles unchanged ‚Äì keep your existing design) */
    * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; font-family:system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    body { background:#111; color:white; height:100vh; overflow:hidden; position:fixed; width:100%; touch-action:pan-x pan-y; }
    #map { position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:1; background:#1a1a1a; }
    .top-header { position:fixed; top:12px; left:12px; right:12px; z-index:20; display:flex; justify-content:space-between; align-items:center; pointer-events:none; transition:opacity 0.2s; }
    .top-header.hidden { opacity:0; pointer-events:none; }
    .activity-chip { background:rgba(20,20,20,0.85); backdrop-filter:blur(12px); padding:10px 18px; border-radius:40px; border:1px solid rgba(255,255,255,0.1); color:white; font-weight:600; font-size:1rem; display:flex; align-items:center; gap:6px; box-shadow:0 4px 12px rgba(0,0,0,0.3); pointer-events:auto; }
    .timer-block { background:rgba(20,20,20,0.85); backdrop-filter:blur(12px); padding:8px 20px; border-radius:40px; border:1px solid rgba(255,255,255,0.1); display:flex; flex-direction:column; align-items:center; line-height:1.2; box-shadow:0 4px 12px rgba(0,0,0,0.3); pointer-events:auto; }
    .timer-label { font-size:0.7rem; opacity:0.7; letter-spacing:0.5px; }
    .timer-value { font-size:1.8rem; font-weight:800; color:#ff8c42; }
    .bottom-sheet { position:fixed; left:0; right:0; bottom:0; z-index:25; background:rgba(18,18,18,0.95); backdrop-filter:blur(20px); border-top-left-radius:30px; border-top-right-radius:30px; color:white; padding:16px 20px 30px; transform:translateY(0); transition:transform 0.3s ease; max-width:500px; margin:0 auto; border-top:1px solid rgba(255,140,66,0.3); box-shadow:0 -10px 30px rgba(0,0,0,0.5); }
    .bottom-sheet.collapsed { transform:translateY(calc(100% - 90px)); }
    .sheet-handle { width:50px; height:5px; background:#ff8c42; border-radius:10px; margin:0 auto 16px; cursor:grab; }
    .stats-row { display:flex; justify-content:space-around; margin-bottom:8px; }
    .stat-block { text-align:center; }
    .stat-value { font-size:1.8rem; font-weight:800; color:#ff8c42; line-height:1.2; }
    .stat-label { font-size:0.75rem; opacity:0.6; text-transform:uppercase; letter-spacing:0.5px; }
    .expanded-content { margin-top:20px; }
    .bottom-sheet.collapsed .expanded-content { display:none; }
    .heart-rate-row, .elevation-row { display:flex; align-items:center; gap:16px; background:rgba(255,255,255,0.05); padding:12px 16px; border-radius:20px; margin:8px 0; }
    .mini-graph { height:40px; background:rgba(255,140,66,0.2); border-radius:20px; flex:1; display:flex; align-items:flex-end; padding:0 4px; }
    .lap-splits { margin:16px 0; }
    .lap-row { display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.1); }
    .capture-btn { background:#ff8c42; border:none; color:black; font-weight:800; font-size:1.2rem; padding:16px; border-radius:40px; width:100%; margin:16px 0 8px; box-shadow:0 8px 20px rgba(255,140,66,0.4); cursor:pointer; }
    .action-btn { position:fixed; bottom:120px; left:50%; transform:translateX(-50%); z-index:30; width:70px; height:70px; border-radius:50%; background:#ff8c42; border:none; box-shadow:0 8px 25px rgba(255,140,66,0.6); color:black; font-size:2rem; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:opacity 0.2s, background 0.2s; border:3px solid rgba(255,255,255,0.3); }
    .action-btn.hidden { opacity:0; pointer-events:none; }
    .action-btn.running { background:#f03e3e; }
    .action-btn.glowing { animation:pulse 1.5s infinite; }
    @keyframes pulse { 0% { box-shadow:0 0 0 0 rgba(255,140,66,0.7); } 70% { box-shadow:0 0 0 15px rgba(255,140,66,0); } 100% { box-shadow:0 0 0 0 rgba(255,140,66,0); } }
    .user-badge { position:fixed; top:12px; right:12px; z-index:21; background:rgba(20,20,20,0.85); backdrop-filter:blur(12px); padding:8px 16px; border-radius:40px; display:flex; align-items:center; gap:8px; border:1px solid rgba(255,140,66,0.3); pointer-events:auto; cursor:pointer; }
    .user-avatar { width:32px; height:32px; background:#ff8c42; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:black; }
    .toast-area { position:fixed; top:100px; left:16px; right:16px; z-index:40; display:flex; flex-direction:column; gap:8px; pointer-events:none; max-width:400px; margin:0 auto; }
    .toast { background:rgba(0,0,0,0.8); backdrop-filter:blur(10px); padding:14px 20px; border-radius:40px; color:white; font-weight:600; display:flex; align-items:center; gap:8px; box-shadow:0 8px 20px rgba(0,0,0,0.5); border-left:5px solid #ff8c42; animation:slideIn 0.3s; }
    .toast.success { border-left-color:#10b981; }
    .toast.warning { border-left-color:#ff8c42; }
    .toast.error { border-left-color:#f03e3e; }
    @keyframes slideIn { from { transform:translateY(-20px); opacity:0; } to { transform:translateY(0); opacity:1; } }
    .post-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); backdrop-filter:blur(8px); z-index:50; display:none; flex-direction:column; align-items:center; justify-content:center; padding:20px; }
    .post-card { background:#1e1e1e; border-radius:40px; padding:30px 20px; width:100%; max-width:400px; text-align:center; }
    .post-stats { display:grid; grid-template-columns:1fr 1fr; gap:20px; margin:30px 0; }
    .share-btn { background:#ff8c42; border:none; padding:16px; border-radius:40px; font-weight:800; width:100%; font-size:1.2rem; cursor:pointer; }
    #loginModal { display:none; }
    .modal-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:100; display:flex; align-items:center; justify-content:center; }
    .modal-content { background:#1e1e1e; padding:30px; border-radius:40px; width:300px; }
    .modal-content h3 { color:#ff8c42; }
    .modal-content input { width:100%; padding:15px; margin:20px 0; border-radius:30px; border:none; background:#333; color:white; }
    .modal-content button { background:#ff8c42; border:none; padding:15px; width:100%; border-radius:30px; font-weight:bold; cursor:pointer; }
    .calibration-warning { position:fixed; top:160px; left:50%; transform:translateX(-50%); background:rgba(255,140,66,0.9); color:black; padding:8px 16px; border-radius:40px; font-size:14px; font-weight:600; z-index:35; display:none; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="calibration-warning" id="calibrationWarning">üìç Waiting for accurate GPS‚Ä¶</div>

  <div class="top-header" id="topHeader">
    <div class="activity-chip"><span>üèÉ</span> <span id="speedDisplay">0.0</span> km/h</div>
    <div class="timer-block"><span class="timer-label">ELAPSED</span><span class="timer-value" id="timerDisplay">00:00</span></div>
  </div>

  <div class="user-badge" id="userBadge" onclick="showLoginModal()">
    <div class="user-avatar" id="userAvatar">üë§</div>
    <span id="userName">Login</span>
  </div>

  <div class="bottom-sheet" id="bottomSheet">
    <div class="sheet-handle" id="sheetHandle"></div>
    <div class="stats-row">
      <div class="stat-block"><div class="stat-value" id="statDistance">0.00</div><div class="stat-label">km</div></div>
      <div class="stat-block"><div class="stat-value" id="statPace">--'--"</div><div class="stat-label">pace</div></div>
      <div class="stat-block"><div class="stat-value" id="statCal">0</div><div class="stat-label">kcal</div></div>
    </div>
    <div class="expanded-content">
      <div class="heart-rate-row"><span>‚ù§Ô∏è 142</span><div class="mini-graph" id="hrGraph"></div></div>
      <div class="elevation-row"><span>‚õ∞Ô∏è 24m</span><div class="mini-graph" id="elevGraph"></div></div>
      <div class="lap-splits" id="lapSplits"></div>
      <button class="capture-btn" id="captureBtn" onclick="claimTerritory()">‚öîÔ∏è CLAIM TERRITORY</button>
    </div>
  </div>

  <button class="action-btn glowing" id="mainAction" onclick="toggleRun()">‚ñ∂Ô∏è</button>
  <div class="toast-area" id="toastArea"></div>

  <div class="post-overlay" id="postOverlay">
    <div class="post-card">
      <h2 style="color:#ff8c42;">üèÅ Activity Complete</h2>
      <div class="post-stats">
        <div><span class="stat-label">Distance</span><br><span class="stat-value" id="postDist">0.00</span> km</div>
        <div><span class="stat-label">Time</span><br><span class="stat-value" id="postTime">00:00</span></div>
        <div><span class="stat-label">Pace</span><br><span class="stat-value" id="postPace">--'--"</span></div>
        <div><span class="stat-label">Steps</span><br><span class="stat-value" id="postSteps">0</span></div>
      </div>
      <button class="share-btn" onclick="shareActivity()">üì§ Share</button>
      <button style="background:transparent; border:none; color:white; margin-top:16px;" onclick="closePost()">Close</button>
    </div>
  </div>

  <div id="loginModal">
    <div class="modal-overlay" onclick="closeLoginModal(event)">
      <div class="modal-content" onclick="event.stopPropagation()">
        <h3>Enter your name</h3>
        <input type="text" id="loginName" placeholder="Runner" autocomplete="off">
        <button onclick="createUser()">Start Running</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    // ---------- CONFIG ----------
    const API_BASE = 'https://kadamclashbackend.onrender.com';
    const ACCENT = '#ff8c42';
    const MIN_DISTANCE = 5;           // meters ‚Äì ignore smaller movements
    const MIN_TIME_MS = 2000;          // 2 seconds between points
    const MAX_SPEED = 20;              // km/h ‚Äì discard unrealistic spikes
    const ACCURACY_THRESHOLD = 20;     // show warning if accuracy >20m
    const STATIONARY_COUNT_LIMIT = 5;  // consecutive stationary readings to lock

    // ---------- STATE ----------
    let map, userMarker, accuracyCircle, pathLayer, territoryLayer, previewLayer;
    let currentPos = null;
    let lastPointTime = 0;
    let lastPointPos = null;
    let watchId = null;
    let isRunning = false;
    let runStartTime = null;
    let runPath = [];
    let totalDistance = 0;
    let lapCount = 0;
    const LAP_DIST = 100;
    let timerInterval;
    let user = null;
    let territories = [];
    let speedReadings = []; // for smoothing
    let stationaryCount = 0;
    let stationaryLock = false; // if true, do NOT record any points

    // ---------- INIT ----------
    function initMap() {
      map = L.map('map', { zoomControl: false, attributionControl: false }).setView([0,0], 18);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

      pathLayer = L.layerGroup().addTo(map);
      territoryLayer = L.layerGroup().addTo(map);
      previewLayer = L.layerGroup().addTo(map);

      // Toggle UI on map tap
      const toggleUI = () => {
        document.getElementById('topHeader').classList.toggle('hidden');
        document.getElementById('mainAction').classList.toggle('hidden');
      };
      map.on('click', toggleUI);
      map.on('touchstart', toggleUI);

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => onLocationUpdate(pos), e => showToast('Location error', 'error'), { enableHighAccuracy: true, maximumAge: 0 });
        watchId = navigator.geolocation.watchPosition(onLocationUpdate, console.warn, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
      }
    }

    function onLocationUpdate(pos) {
      const { latitude, longitude, accuracy, speed } = pos.coords;
      const newPos = [latitude, longitude];
      currentPos = newPos;

      // Accuracy warning
      const warningEl = document.getElementById('calibrationWarning');
      if (accuracy > ACCURACY_THRESHOLD) {
        warningEl.style.display = 'block';
      } else {
        warningEl.style.display = 'none';
      }

      // Update marker
      if (!userMarker) {
        userMarker = L.marker(newPos, { icon: L.divIcon({ html: 'üìç', className: 'user-dot', iconSize: [30,30] }) }).addTo(map);
        accuracyCircle = L.circle(newPos, { radius: accuracy, color: ACCENT, fillOpacity: 0.1 }).addTo(map);
      } else {
        userMarker.setLatLng(newPos);
        accuracyCircle.setLatLng(newPos).setRadius(accuracy);
      }

      // Smooth speed (moving average)
      let rawSpeed = speed ? speed * 3.6 : 0;
      if (rawSpeed > MAX_SPEED) rawSpeed = MAX_SPEED; // cap
      speedReadings.push(rawSpeed);
      if (speedReadings.length > 5) speedReadings.shift();
      const avgSpeed = speedReadings.reduce((a,b)=>a+b,0) / speedReadings.length;
      document.getElementById('speedDisplay').innerText = avgSpeed.toFixed(1);

      // Stationary detection
      const isMoving = avgSpeed >= 1.0; // 1 km/h threshold
      const now = Date.now();
      let distSinceLast = 0;
      if (lastPointPos) {
        distSinceLast = distance(lastPointPos[0], lastPointPos[1], newPos[0], newPos[1]);
      }

      if (!isMoving && distSinceLast < MIN_DISTANCE) {
        stationaryCount++;
        if (stationaryCount >= STATIONARY_COUNT_LIMIT) {
          stationaryLock = true;
        }
      } else {
        // Movement detected ‚Äì reset lock
        stationaryCount = 0;
        stationaryLock = false;
      }

      // Record point if running and not locked
      if (isRunning && !stationaryLock) {
        let shouldRecord = false;

        if (runPath.length === 0) {
          shouldRecord = true; // first point always
        } else {
          const last = runPath[runPath.length-1];
          const dist = distance(last.lat, last.lng, newPos[0], newPos[1]);
          const timeSince = now - lastPointTime;

          // Record if moved enough OR (time passed and moving)
          if (dist >= MIN_DISTANCE) {
            shouldRecord = true;
          } else if (timeSince >= MIN_TIME_MS && isMoving) {
            shouldRecord = true;
          }
        }

        if (shouldRecord) {
          addRunPoint(newPos, avgSpeed);
          lastPointTime = now;
          lastPointPos = newPos;
          map.panTo(newPos);
        }
      }
    }

    function addRunPoint(pos, spd) {
      runPath.push({ lat: pos[0], lng: pos[1], time: Date.now(), speed: spd });
      updatePathDisplay();
      updateRunStats();
    }

    function updatePathDisplay() {
      pathLayer.clearLayers();
      if (runPath.length < 2) return;
      const latlngs = runPath.map(p => [p.lat, p.lng]);
      L.polyline(latlngs, { color: ACCENT, weight: 5, opacity: 0.8 }).addTo(pathLayer);
      L.circleMarker([runPath[0].lat, runPath[0].lng], { radius: 6, color: '#10b981' }).addTo(pathLayer);
      if (runPath.length >= 5) showPreview();
    }

    function showPreview() {
      previewLayer.clearLayers();
      try {
        const points = runPath.map(p => [p.lng, p.lat]);
        const line = turf.lineString(points);
        const buffer = turf.buffer(line, 15, { units: 'meters' });
        if (buffer) {
          const coords = buffer.geometry.coordinates[0].map(c => [c[1], c[0]]);
          L.polygon(coords, { color: ACCENT, weight: 2, fillOpacity: 0.15, dashArray: '5,5' }).addTo(previewLayer);
        }
      } catch (e) {}
    }

    function updateRunStats() {
      if (runPath.length < 2) return;
      let dist = 0;
      for (let i=1; i<runPath.length; i++) {
        dist += distance(runPath[i-1].lat, runPath[i-1].lng, runPath[i].lat, runPath[i].lng);
      }
      totalDistance = dist;
      const elapsed = (Date.now() - runStartTime) / 1000;
      const pace = elapsed / 60 / (dist/1000) || 0;
      const paceMin = Math.floor(pace);
      const paceSec = Math.floor((pace - paceMin)*60);
      document.getElementById('statDistance').innerText = (dist/1000).toFixed(2);
      document.getElementById('statPace').innerText = `${paceMin}'${paceSec.toString().padStart(2,'0')}"`;
      document.getElementById('timerDisplay').innerText = formatTime(elapsed);
      document.getElementById('statCal').innerText = Math.floor(dist * 1.036);

      const laps = Math.floor(dist / LAP_DIST);
      if (laps > lapCount) {
        lapCount = laps;
        showToast(`üèÅ Lap ${lapCount}`, 'success');
        const splitsDiv = document.getElementById('lapSplits');
        splitsDiv.innerHTML = '';
        for (let i=1; i<=lapCount; i++) {
          splitsDiv.innerHTML += `<div class="lap-row"><span>Lap ${i}</span><span>${formatTime(i*LAP_DIST/3.5)}</span></div>`;
        }
      }
    }

    function distance(lat1,lng1,lat2,lng2) {
      const R = 6371e3;
      const œÜ1 = lat1*Math.PI/180, œÜ2 = lat2*Math.PI/180;
      const ŒîœÜ = (lat2-lat1)*Math.PI/180, ŒîŒª = (lng2-lng1)*Math.PI/180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function formatTime(sec) {
      const m = Math.floor(sec/60);
      const s = Math.floor(sec%60);
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    // ---------- RUN CONTROL ----------
    function toggleRun() {
      if (!user) { showLoginModal(); return; }
      if (!isRunning) {
        startRun();
      } else {
        stopRun();
      }
    }

    function startRun() {
      isRunning = true;
      runStartTime = Date.now();
      runPath = [];
      totalDistance = 0;
      lapCount = 0;
      speedReadings = [];
      stationaryCount = 0;
      stationaryLock = false;
      pathLayer.clearLayers();
      previewLayer.clearLayers();
      document.getElementById('mainAction').innerHTML = '‚è∏Ô∏è';
      document.getElementById('mainAction').classList.add('running');
      document.getElementById('mainAction').classList.remove('glowing');
      showToast('Run started ‚Äî move to create territory', 'success');
      timerInterval = setInterval(() => {
        if (isRunning) updateRunStats();
      }, 1000);
    }

    async function stopRun() {
      isRunning = false;
      clearInterval(timerInterval);
      document.getElementById('mainAction').innerHTML = '‚ñ∂Ô∏è';
      document.getElementById('mainAction').classList.remove('running');
      document.getElementById('mainAction').classList.add('glowing');

      if (runPath.length < 5) {
        showToast('Run too short, no territory', 'warning');
        resetRun();
        return;
      }

      const polygon = createPolygonFromPath(runPath);
      if (!polygon) { showToast('Polygon error', 'error'); resetRun(); return; }

      const duration = Math.floor((Date.now() - runStartTime)/1000);
      const avgSpeed = runPath.filter(p=>p.speed>1).reduce((a,b)=>a+b.speed,0) / (runPath.filter(p=>p.speed>1).length || 1);

      showToast('Submitting run...', 'info');

      try {
        const res = await fetch(`${API_BASE}/api/run`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: user.id,
            polygon: polygon,
            duration: duration,
            laps: lapCount || 1,
            avgSpeed: avgSpeed
          })
        });
        const result = await res.json();
        if (result.created) {
          showToast('‚ú® New territory created!', 'success');
          animateCapture();
        } else if (result.captured) {
          showToast('‚öîÔ∏è Territory CAPTURED! +50 points', 'success');
          animateCapture();
        } else {
          showToast('Run recorded, no capture', 'info');
        }
        loadTerritories();
        showPostActivity();
      } catch (e) {
        showToast('Error: ' + e.message, 'error');
      } finally {
        resetRun();
      }
    }

    function createPolygonFromPath(path) {
      try {
        const points = path.map(p => [p.lng, p.lat]);
        const line = turf.lineString(points);
        const buffer = turf.buffer(line, 15, { units: 'meters' });
        if (!buffer) return null;
        return turf.simplify(buffer, { tolerance: 0.0001 }).geometry;
      } catch { return null; }
    }

    function resetRun() {
      runPath = [];
      pathLayer.clearLayers();
      previewLayer.clearLayers();
      document.getElementById('statDistance').innerText = '0.00';
      document.getElementById('statPace').innerText = "--'--\"";
      document.getElementById('statCal').innerText = '0';
    }

    // ---------- TERRITORY UI ----------
    async function loadTerritories() {
      try {
        const res = await fetch(`${API_BASE}/api/territories`);
        const data = await res.json();
        territories = data;
        territoryLayer.clearLayers();
        data.forEach(t => {
          if (!t.geometry?.coordinates) return;
          const coords = t.geometry.coordinates[0].map(c => [c[1], c[0]]);
          const isOwn = t.ownerId?._id === user?.id || t.ownerId === user?.id;
          const polygon = L.polygon(coords, {
            color: isOwn ? '#10b981' : '#f03e3e',
            weight: 4,
            fillColor: isOwn ? '#10b981' : '#f03e3e',
            fillOpacity: 0.2
          }).addTo(territoryLayer);
          polygon.on('click', () => {
            showToast(`Owner: ${t.ownerId?.username || 'Unknown'} ¬∑ ${t.area?.toFixed(0)}m¬≤`, 'info');
          });
        });
      } catch (e) {}
    }

    function animateCapture() {
      map.getContainer().style.transition = 'box-shadow 0.2s';
      map.getContainer().style.boxShadow = 'inset 0 0 30px #ff8c42';
      setTimeout(() => map.getContainer().style.boxShadow = '', 500);
    }

    function claimTerritory() {
      if (!isRunning && runPath.length > 0) {
        stopRun();
      } else {
        showToast('Finish your run first', 'warning');
      }
    }

    // ---------- USER ----------
    function showLoginModal() { document.getElementById('loginModal').style.display = 'block'; }
    function closeLoginModal(e) { if (e.target.classList.contains('modal-overlay')) document.getElementById('loginModal').style.display = 'none'; }
    async function createUser() {
      const name = document.getElementById('loginName').value.trim();
      if (!name) return;
      try {
        const res = await fetch(`${API_BASE}/api/users`, {
          method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ username: name })
        });
        const u = await res.json();
        user = { id: u.id || u._id, username: u.username };
        localStorage.setItem('kadamUser', JSON.stringify(user));
        document.getElementById('userName').innerText = user.username;
        document.getElementById('userAvatar').innerText = user.username[0].toUpperCase();
        document.getElementById('loginModal').style.display = 'none';
        showToast(`Welcome ${user.username}!`, 'success');
        loadTerritories();
      } catch(e) { showToast('Error','error'); }
    }

    // ---------- POST ACTIVITY ----------
    function showPostActivity() {
      document.getElementById('postDist').innerText = (totalDistance/1000).toFixed(2);
      document.getElementById('postTime').innerText = formatTime((Date.now()-runStartTime)/1000);
      document.getElementById('postPace').innerText = document.getElementById('statPace').innerText;
      const steps = Math.floor(totalDistance / 0.76);
      document.getElementById('postSteps').innerText = steps;
      document.getElementById('postOverlay').style.display = 'flex';
    }
    function closePost() { document.getElementById('postOverlay').style.display = 'none'; }
    function shareActivity() { alert('Share mocked'); }

    // ---------- UI HELPERS ----------
    function showToast(msg, type='info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerText = msg;
      document.getElementById('toastArea').appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // bottom sheet drag
    const sheet = document.getElementById('bottomSheet');
    const handle = document.getElementById('sheetHandle');
    let startY = 0;
    handle.addEventListener('touchstart', e => startY = e.touches[0].clientY);
    handle.addEventListener('touchmove', e => {
      const dy = e.touches[0].clientY - startY;
      if (dy > 50) sheet.classList.add('collapsed');
      else if (dy < -50) sheet.classList.remove('collapsed');
    });

    // load saved user
    (function() {
      const saved = localStorage.getItem('kadamUser');
      if (saved) {
        user = JSON.parse(saved);
        document.getElementById('userName').innerText = user.username;
        document.getElementById('userAvatar').innerText = user.username[0].toUpperCase();
        loadTerritories();
      }
    })();

    initMap();
    setInterval(loadTerritories, 8000);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kadam Clash ‚Äì territory runner</title>
  
  <!-- Leaflet & Turf (keep original) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  
  <style>
    /* ----------------------------------------------
       RESET + GLOBAL ‚Äì MOBILE FIRST, MODERN FIT 
    ------------------------------------------------ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, sans-serif;
    }

    body {
      background: #030712;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      touch-action: pan-x pan-y;
    }

    /* ---------- MAP (fullscreen, dark subtle) ---------- */
    #map {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }

    .leaflet-tile {
      filter: brightness(0.75) contrast(1.2) saturate(0.9) grayscale(0.2);
    }

    /* custom user marker (glowing dot) */
    .user-marker {
      background: transparent;
    }
    .user-marker div {
      width: 20px;
      height: 20px;
      background: #22c55e;
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(34,197,94,0.3), 0 0 20px #22c55e;
      border: 2px solid white;
    }

    /* ---------- TOP BAR ‚Äì glass, minimal ---------- */
    .top-bar {
      position: fixed;
      top: 16px;
      left: 16px;
      right: 16px;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      gap: 10px;
    }

    .menu-btn {
      width: 48px;
      height: 48px;
      border-radius: 40px;
      background: rgba(17, 25, 40, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      box-shadow: 0 12px 30px rgba(0,0,0,0.7);
      cursor: pointer;
    }

    .menu-btn div {
      width: 20px;
      height: 2px;
      background: white;
      border-radius: 4px;
      position: relative;
    }
    .menu-btn div::before,
    .menu-btn div::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 2px;
      background: white;
      border-radius: 4px;
      left: 0;
      transition: 0.2s;
    }
    .menu-btn div::before { top: -6px; }
    .menu-btn div::after { top: 6px; }

    .location-chip {
      background: rgba(17, 25, 40, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 40px;
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 500;
      color: white;
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 45vw;
    }

    .location-chip .dot {
      width: 10px;
      height: 10px;
      background: #22c55e;
      border-radius: 10px;
      box-shadow: 0 0 10px #22c55e;
    }

    .status-chip {
      background: rgba(17, 25, 40, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 40px;
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      pointer-events: auto;
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    .status-chip.online {
      background: rgba(5, 46, 26, 0.9);
      border-color: #22c55e;
    }

    /* ---------- SIDE MENU (modern, dark, blur) ---------- */
    .side-menu {
      position: fixed;
      top: 0;
      left: -300px;
      width: 280px;
      height: 100vh;
      background: rgba(11, 15, 25, 0.95);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-right: 1px solid rgba(255,255,255,0.05);
      z-index: 200;
      padding: 30px 20px;
      transition: left 0.35s cubic-bezier(0.2, 0.9, 0.3, 1);
      box-shadow: 10px 0 50px rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
    }

    .side-menu.open {
      left: 0;
    }

    .side-menu h2 {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, #22c55e, #86efac);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 40px;
      padding-left: 8px;
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 18px 16px;
      border-radius: 20px;
      font-size: 17px;
      font-weight: 500;
      color: #eee;
      margin-bottom: 8px;
      transition: all 0.2s;
      cursor: pointer;
      border: 1px solid transparent;
    }

    .menu-item:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(34,197,94,0.3);
    }

    .menu-item .icon {
      font-size: 24px;
      width: 32px;
      text-align: center;
    }

    .profile-row {
      margin-top: auto;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 20px;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }

    .profile-row .menu-item {
      width: 100%;
      margin-bottom: 0;
    }

    #profileUsername {
      font-size: 15px;
      color: #22c55e;
      font-weight: 600;
      margin-left: 48px;
      margin-top: -8px;
      margin-bottom: 12px;
      display: block;
    }

    /* ---------- BOTTOM RUN CARD ‚Äì like fitness app ---------- */
    .run-card-container {
      position: fixed;
      bottom: 20px;
      left: 16px;
      right: 16px;
      z-index: 60;
      pointer-events: none;
    }

    .run-card {
      background: rgba(17, 25, 40, 0.9);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-radius: 40px;
      padding: 24px 22px 28px;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 25px 50px -8px black;
      pointer-events: auto;
      transition: transform 0.2s;
    }

    .runner-profile {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .runner-avatar {
      width: 52px;
      height: 52px;
      background: linear-gradient(145deg, #1e293b, #0f172a);
      border-radius: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      border: 2px solid #22c55e;
      box-shadow: 0 8px 18px rgba(34,197,94,0.3);
    }

    .runner-name {
      font-size: 20px;
      font-weight: 700;
      color: white;
    }

    .runner-name small {
      font-size: 14px;
      font-weight: 400;
      color: #94a3b8;
      display: block;
    }

    /* big distance */
    .distance-block {
      text-align: center;
      margin: 10px 0 8px;
    }

    .distance-number {
      font-size: 5rem;
      font-weight: 800;
      line-height: 1;
      letter-spacing: -2px;
      background: linear-gradient(180deg, #fff 30%, #94a3b8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .distance-unit {
      font-size: 1.4rem;
      font-weight: 500;
      color: #64748b;
      margin-left: 8px;
    }

    .location-badge {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      color: #a0afc0;
      font-size: 15px;
      font-weight: 400;
      margin-bottom: 24px;
    }

    .location-badge .icon {
      font-size: 18px;
    }

    /* stats row (three columns) */
    .stats-row {
      display: flex;
      justify-content: space-between;
      background: rgba(0,0,0,0.3);
      border-radius: 60px;
      padding: 16px 14px;
      margin-bottom: 28px;
      border: 1px solid rgba(255,255,255,0.05);
    }

    .stat-item {
      text-align: center;
      flex: 1;
    }

    .stat-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #94a3b8;
      margin-bottom: 6px;
    }

    .stat-value {
      font-size: 22px;
      font-weight: 700;
      color: white;
    }

    .stat-unit {
      font-size: 11px;
      color: #64748b;
      margin-left: 2px;
    }

    /* main CTA button */
    .run-action-btn {
      width: 100%;
      padding: 20px;
      border: none;
      border-radius: 60px;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(95deg, #22c55e, #16a34a);
      color: #0f172a;
      box-shadow: 0 16px 30px rgba(34,197,94,0.5);
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .run-action-btn.running {
      background: linear-gradient(95deg, #ef4444, #b91c1c);
      box-shadow: 0 16px 30px rgba(239,68,68,0.4);
      color: white;
    }

    .run-action-btn:disabled {
      opacity: 0.5;
      box-shadow: none;
    }

    .hint-text {
      text-align: center;
      margin-top: 14px;
      font-size: 13px;
      color: #6b7280;
    }

    /* toast */
    .toast {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      backdrop-filter: blur(20px);
      padding: 14px 28px;
      border-radius: 60px;
      font-weight: 600;
      display: none;
      z-index: 300;
      box-shadow: 0 20px 40px black;
      border: 1px solid rgba(255,255,255,0.1);
      color: white;
    }
    .toast.success { background: #166534; }
    .toast.error { background: #7f1d1d; }

    /* hidden userSelector (kept for logic) */
    #userSelector { display: none; }

    /* small adjustments */
    @media (max-width: 380px) {
      .distance-number { font-size: 4.2rem; }
      .stats-row { padding: 12px 6px; }
    }
  </style>
</head>
<body>

  <!-- MAP (fullscreen) -->
  <div id="map"></div>

  <!-- SIDE MENU with four items + profile username -->
  <div class="side-menu" id="sideMenu">
    <h2>‚ö° KADAM</h2>
    
    <div class="menu-item" onclick="alert('üèÜ Run to Win ‚Äì start moving!')">
      <span class="icon">üèÜ</span> Run to Win
    </div>
    <div class="menu-item" onclick="alert('üó∫ My territories would appear here')">
      <span class="icon">üó∫</span> My Territories
    </div>
    <div class="menu-item" onclick="alert('ü•á Leaderboard ‚Äì coming soon')">
      <span class="icon">ü•á</span> Leaderboard
    </div>

    <!-- Profile section with dynamic username -->
    <div class="profile-row">
      <div class="menu-item" onclick="selectRunner()">
        <span class="icon">üë§</span> My Profile
      </div>
      <span id="profileUsername">(not logged in)</span>
    </div>
  </div>

  <!-- TOP GLASS BAR -->
  <div class="top-bar">
    <div class="menu-btn" onclick="toggleMenu()">
      <div></div>
    </div>
    <div class="location-chip" id="locationInfo">
      <span class="dot"></span> üì° GPS...
    </div>
    <div class="status-chip" id="apiStatus">
      ‚ö° connecting
    </div>
  </div>

  <!-- BOTTOM RUN CARD (completely redesigned) -->
  <div class="run-card-container">
    <div class="run-card" id="runCard">

      <!-- runner avatar + name (dynamic) -->
      <div class="runner-profile">
        <div class="runner-avatar" id="runnerAvatar">üèÉ</div>
        <div class="runner-name" id="runnerDisplay">
          Start Running
          <small>ready</small>
        </div>
      </div>

      <!-- big distance display (like 1.4 km screenshot) -->
      <div class="distance-block">
        <span class="distance-number" id="distance">0.00</span>
        <span class="distance-unit">km</span>
      </div>

      <!-- location hint (static for design, but we inject coords) -->
      <div class="location-badge">
        <span class="icon">üìç</span> <span id="runLocation">Alun-Alun Serang</span>
      </div>

      <!-- three key stats: duration, laps, speed -->
      <div class="stats-row">
        <div class="stat-item">
          <div class="stat-label">duration</div>
          <div class="stat-value" id="duration">00:00</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">laps</div>
          <div class="stat-value" id="laps">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">speed</div>
          <div class="stat-value" id="avgSpeed">0.0</div>
          <span class="stat-unit">km/h</span>
        </div>
      </div>

      <!-- main action button -->
      <button class="run-action-btn" id="runBtn" onclick="toggleRun()" disabled>
        ‚ñ∂ START RUN
      </button>
      <div class="hint-text" id="runHint">
        üë§ select profile to begin
      </div>

    </div>
  </div>

  <!-- toast & hidden userSelector (for legacy code) -->
  <div id="toast" class="toast"></div>
  <div id="userSelector"></div>

  <script>
    (function() {
      // --------------------------------------------------------------
      // ORIGINAL LOGIC ‚Äì FULLY PRESERVED (only added profile update & cleanup)
      // --------------------------------------------------------------
      const API_BASE = 'https://kadamclashbackend.onrender.com';
      const MOVEMENT_THRESHOLD = 5;
      const LAP_RADIUS = 50;
      const TERRITORY_BUFFER = 10;

      let map;
      let currentPosition = null;
      let watchId = null;
      let isRunning = false;
      let selectedUserId = null;
      let selectedUsername = null;

      let runPath = [];
      let runStartTime = null;
      let runTimer = null;
      let lapCount = 0;
      let lastLapCheckPosition = null;

      let userMarker = null;
      let accuracyCircle = null;
      let pathLayer = L.layerGroup();
      let territoryLayer = L.layerGroup();

      // UI elements (some are new but IDs unchanged)
      const locationEl = document.getElementById('locationInfo');
      const apiStatusEl = document.getElementById('apiStatus');
      const runBtn = document.getElementById('runBtn');
      const runCard = document.getElementById('runCard');
      const runnerDisplay = document.getElementById('runnerDisplay');
      const runHint = document.getElementById('runHint');
      const distanceEl = document.getElementById('distance');
      const durationEl = document.getElementById('duration');
      const lapsEl = document.getElementById('laps');
      const avgSpeedEl = document.getElementById('avgSpeed');
      const toast = document.getElementById('toast');
      const runLocationSpan = document.getElementById('runLocation'); // new element for location name
      
      // Profile username span (side menu)
      const profileUsernameSpan = document.getElementById('profileUsername');
      const runnerAvatar = document.getElementById('runnerAvatar');

      // Helper: show toast
      function showToast(message, type = 'info') {
        toast.className = `toast ${type}`;
        toast.innerHTML = message;
        toast.style.display = 'flex';
        setTimeout(() => { toast.style.display = 'none'; }, 3500);
      }

      // API health
      async function checkAPI() {
        try {
          const res = await fetch(`${API_BASE}/health`);
          const data = await res.json();
          if (data.database === 'connected') {
            apiStatusEl.className = 'status-chip online';
            apiStatusEl.innerHTML = '‚úÖ server ready';
          } else {
            apiStatusEl.innerHTML = '‚ö†Ô∏è DB issue';
          }
        } catch {
          apiStatusEl.innerHTML = '‚ùå offline';
        }
      }
      checkAPI();
      setInterval(checkAPI, 15000);

      // Update profile UI when user logs in
      function updateProfileUI() {
        if (selectedUsername) {
          runnerDisplay.innerHTML = `${selectedUsername} <small>runner</small>`;
          runnerAvatar.innerText = 'üèÉ';
          profileUsernameSpan.innerText = `@${selectedUsername}`;
          runHint.innerText = 'ready to run';
        } else {
          runnerDisplay.innerHTML = 'Start Running <small>tap profile</small>';
          runnerAvatar.innerText = 'üë§';
          profileUsernameSpan.innerText = '(not logged in)';
        }
      }

      // Modified selectRunner to also update side menu
      window.selectRunner = async function() {
        const name = prompt('Enter your runner name (new or existing):');
        if (!name || !name.trim()) return;
        const trimmed = name.trim();
        try {
          const res = await fetch(`${API_BASE}/api/users`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: trimmed })
          });
          const user = await res.json();
          selectedUserId = user.id || user._id;
          selectedUsername = user.username;

          updateProfileUI();
          runBtn.disabled = false;
          runHint.innerText = 'Ready to run';
          showToast(`Welcome, ${selectedUsername}!`, 'success');
          loadTerritories();
          // close menu after selection? optional
          document.getElementById('sideMenu').classList.remove('open');
        } catch (e) {
          showToast('User creation failed', 'error');
        }
      };

      // Load territories
      async function loadTerritories() {
        if (!selectedUserId) return;
        try {
          const res = await fetch(`${API_BASE}/api/territories`);
          const territories = await res.json();
          territoryLayer.clearLayers();
          territories.forEach(t => {
            if (!t.geometry || !t.geometry.coordinates) return;
            const coords = t.geometry.coordinates[0].map(c => [c[1], c[0]]);
            const isOwn = (t.ownerId?._id === selectedUserId || t.ownerId === selectedUserId);
            const polygon = L.polygon(coords, {
              color: isOwn ? '#22c55e' : '#ef4444',
              weight: 3,
              fillColor: isOwn ? '#22c55e' : '#ef4444',
              fillOpacity: 0.2,
              interactive: true
            }).addTo(territoryLayer);
            polygon.bindPopup(`
              <b>${isOwn ? 'YOUR' : 'ENEMY'} TERRITORY</b><br>
              Owner: ${t.ownerId?.username || 'Unknown'}<br>
              Area: ${t.area ? t.area.toFixed(0) : 'N/A'} m¬≤<br>
              Best lap: ${t.bestTime ? t.bestTime.toFixed(1) : 'N/A'}s
            `);
          });
        } catch (e) {
          console.warn('Failed to load territories', e);
        }
      }

      // Map init
      function initMap() {
        map = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap'
        }).addTo(map);

        pathLayer.addTo(map);
        territoryLayer.addTo(map);

        if (!navigator.geolocation) {
          locationEl.innerHTML = '‚ùå GPS not supported';
          return;
        }
        navigator.geolocation.getCurrentPosition(initPosition, handleGeoError, {
          enableHighAccuracy: true,
          timeout: 10000
        });

        watchId = navigator.geolocation.watchPosition(updatePosition, handleGeoError, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      }

      function handleGeoError(err) {
        locationEl.innerHTML = '‚ùå Location denied';
        showToast('Please enable GPS', 'error');
      }

      function initPosition(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        currentPosition = [latitude, longitude];
        map.setView(currentPosition, 17);

        userMarker = L.marker(currentPosition, {
          icon: L.divIcon({ className: 'user-marker', html: '<div></div>', iconSize: [20,20] })
        }).addTo(map);

        accuracyCircle = L.circle(currentPosition, {
          radius: accuracy,
          color: '#3b82f6',
          fillColor: '#3b82f6',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(map);

        locationEl.innerHTML = `üìç ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
        runLocationSpan.innerText = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`; // show in run card
      }

      function updatePosition(pos) {
        const { latitude, longitude, accuracy, speed } = pos.coords;
        if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) return;

        const newPos = [latitude, longitude];
        currentPosition = newPos;

        if (userMarker) userMarker.setLatLng(newPos);
        if (accuracyCircle) {
          accuracyCircle.setLatLng(newPos);
          accuracyCircle.setRadius(accuracy);
        }

        const speedKmh = speed ? (speed * 3.6).toFixed(1) : '?';
        locationEl.innerHTML = `üìç ${latitude.toFixed(5)}, ${longitude.toFixed(5)} | ${speedKmh} km/h`;
        runLocationSpan.innerText = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;

        if (isRunning) {
          addPointToRun(newPos, speed);
        }
      }

      // (the rest of the logic ‚Äì addPointToRun, drawRunPath, updateRunStats, startRun, stopRun, etc. ‚Äì is exactly as original)
      // We'll embed them unchanged. (They are long but we keep them identical to avoid bugs)
      
      function addPointToRun(pos, speedMs) {
        if (!runPath.length) {
          runPath.push({ lat: pos[0], lng: pos[1], timestamp: Date.now(), speed: speedMs || 0 });
          lastLapCheckPosition = pos;
          drawRunPath();
          return;
        }
        const last = runPath[runPath.length-1];
        const lastPos = [last.lat, last.lng];
        const dist = calculateDistance(lastPos, pos);
        if (dist < MOVEMENT_THRESHOLD && (!speedMs || speedMs < 0.5)) return;

        runPath.push({ lat: pos[0], lng: pos[1], timestamp: Date.now(), speed: speedMs || 0 });

        if (runPath.length > 5) {
          const start = [runPath[0].lat, runPath[0].lng];
          const distToStart = calculateDistance(pos, start);
          if (distToStart <= LAP_RADIUS) {
            if (lastLapCheckPosition) {
              const distFromLastLap = calculateDistance(pos, lastLapCheckPosition);
              if (distFromLastLap > LAP_RADIUS * 1.5) {
                lapCount++;
                lapsEl.innerText = lapCount;
                lastLapCheckPosition = pos;
                showToast(`üèÅ Lap ${lapCount}!`, 'success');
              }
            } else {
              lapCount++;
              lapsEl.innerText = lapCount;
              lastLapCheckPosition = pos;
            }
          }
        }
        drawRunPath();
        updateRunStats();
      }

      function drawRunPath() {
        pathLayer.clearLayers();
        if (runPath.length < 2) return;
        const latlngs = runPath.map(p => [p.lat, p.lng]);
        L.polyline(latlngs, { color: '#3b82f6', weight: 5, opacity: 0.8 }).addTo(pathLayer);
        L.circleMarker([runPath[0].lat, runPath[0].lng], { radius: 6, color: '#22c55e', fillColor: '#22c55e', fillOpacity: 1 }).addTo(pathLayer);
        L.circleMarker([runPath[runPath.length-1].lat, runPath[runPath.length-1].lng], { radius: 6, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 1 }).addTo(pathLayer);
      }

      function updateRunStats() {
        if (runPath.length < 2 || !runStartTime) return;
        let totalM = 0;
        for (let i=1; i<runPath.length; i++) {
          totalM += calculateDistance([runPath[i-1].lat, runPath[i-1].lng], [runPath[i].lat, runPath[i].lng]);
        }
        const distKm = totalM / 1000;
        distanceEl.innerText = distKm.toFixed(2);
        const secs = Math.floor((Date.now() - runStartTime) / 1000);
        const mins = Math.floor(secs/60);
        const remainingSecs = secs % 60;
        durationEl.innerText = `${mins.toString().padStart(2,'0')}:${remainingSecs.toString().padStart(2,'0')}`;
        const hours = secs / 3600;
        const avg = hours > 0 ? distKm / hours : 0;
        avgSpeedEl.innerText = avg.toFixed(1);
      }

      window.toggleRun = function() {
        if (!selectedUserId) {
          showToast('Select a runner first', 'error');
          return;
        }
        if (!isRunning) startRun();
        else stopRun();
      };

      function startRun() {
        if (!currentPosition) {
          showToast('Waiting for GPS', 'error');
          return;
        }
        isRunning = true;
        runStartTime = Date.now();
        runPath = [];
        lapCount = 0;
        lastLapCheckPosition = null;
        pathLayer.clearLayers();
        runBtn.innerText = '‚èπÔ∏è STOP RUN';
        runBtn.classList.add('running');
        runCard.classList.add('running');
        runHint.innerText = 'üèÉ moving ‚Äì claim territory';
        runnerDisplay.innerHTML = `${selectedUsername} <small>running</small>`;
        addPointToRun(currentPosition, 0);
        runTimer = setInterval(() => { if (isRunning) updateRunStats(); }, 1000);
        showToast('Run started!', 'success');
      }

      async function stopRun() {
        isRunning = false;
        clearInterval(runTimer);
        runBtn.innerText = '‚ñ∂ START RUN';
        runBtn.classList.remove('running');
        runCard.classList.remove('running');
        runHint.innerText = 'Processing run...';
        runBtn.disabled = true;

        if (runPath.length < 5) {
          showToast('Run too short (need more movement)', 'error');
          resetRunUI();
          return;
        }

        try {
          const lineCoords = runPath.map(p => [p.lng, p.lat]);
          const line = turf.lineString(lineCoords);
          const buffered = turf.buffer(line, TERRITORY_BUFFER, { units: 'meters' });
          if (!buffered || !buffered.geometry) throw new Error('Buffer failed');
          const duration = Math.floor((Date.now() - runStartTime) / 1000);
          const totalDistM = runPath.slice(1).reduce((acc, _, i) => {
            return acc + calculateDistance([runPath[i].lat, runPath[i].lng], [runPath[i+1].lat, runPath[i+1].lng]);
          }, 0);
          const avgSpeed = (totalDistM/1000) / (duration/3600);
          const payload = {
            userId: selectedUserId,
            polygon: buffered.geometry,
            duration: duration,
            laps: lapCount || 1,
            avgSpeed: avgSpeed || 0
          };
          const res = await fetch(`${API_BASE}/api/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const result = await res.json();
          if (result.created) showToast('‚ú® New territory created!', 'success');
          else if (result.captured) showToast('‚öîÔ∏è Territory CAPTURED!', 'success');
          else showToast('üèÉ Run recorded', 'info');
          loadTerritories();
        } catch (err) {
          showToast('Error submitting run: ' + err.message, 'error');
        } finally {
          resetRunUI();
        }
      }

      function resetRunUI() {
        runPath = [];
        pathLayer.clearLayers();
        distanceEl.innerText = '0.00';
        durationEl.innerText = '00:00';
        lapsEl.innerText = '0';
        avgSpeedEl.innerText = '0.0';
        runBtn.disabled = false;
        runHint.innerText = 'Ready';
        runnerDisplay.innerHTML = `${selectedUsername} <small>runner</small>`;
      }

      function calculateDistance(p1, p2) {
        const R = 6371e3;
        const œÜ1 = p1[0] * Math.PI / 180;
        const œÜ2 = p2[0] * Math.PI / 180;
        const ŒîœÜ = (p2[0] - p1[0]) * Math.PI / 180;
        const ŒîŒª = (p2[1] - p1[1]) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ/2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      // clean up old event listener (infoToggle removed)
      // no infoToggle in new HTML, so we skip that.

      window.addEventListener('beforeunload', () => {
        if (watchId) navigator.geolocation.clearWatch(watchId);
      });

      // side menu toggle
      window.toggleMenu = function() {
        document.getElementById('sideMenu').classList.toggle('open');
      };

      // Initialize
      initMap();
      updateProfileUI(); // set default (not logged in)
    })();
  </script>
</body>
</html>

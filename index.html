<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kadam Clash ‚Äì territory runner</title>
  
  <!-- Leaflet & Turf -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  
  <style>
    /* ---------- RESET ‚Äì MOBILE FIRST, MAP FOCUSED ---------- */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, sans-serif;
    }

    body {
      background: #030712;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      touch-action: pan-x pan-y;
    }

    /* ---------- MAP ---------- */
    #map {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }

    .leaflet-tile {
      filter: brightness(0.75) contrast(1.2) saturate(0.9) grayscale(0.2);
    }

    .leaflet-control-zoom {
      display: none !important;
    }

    .user-marker {
      background: transparent;
    }
    .user-marker div {
      width: 22px;
      height: 22px;
      background: #22c55e;
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(34,197,94,0.3), 0 0 15px #22c55e;
      border: 2.5px solid white;
    }

    .leaflet-interactive {
      stroke-width: 4 !important;
      stroke-opacity: 1 !important;
      fill-opacity: 0.45 !important;
    }

    /* ---------- TOP BAR ‚Äì only hamburger ---------- */
    .top-bar {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 50;
      pointer-events: none;
    }

    .menu-btn {
      width: 48px;
      height: 48px;
      border-radius: 40px;
      background: rgba(17, 25, 40, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      box-shadow: 0 12px 30px rgba(0,0,0,0.7);
      cursor: pointer;
    }

    .menu-btn div {
      width: 20px;
      height: 2px;
      background: white;
      border-radius: 4px;
      position: relative;
    }
    .menu-btn div::before,
    .menu-btn div::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 2px;
      background: white;
      border-radius: 4px;
      left: 0;
    }
    .menu-btn div::before { top: -6px; }
    .menu-btn div::after { top: 6px; }

    /* ---------- SIDE MENU ---------- */
    .menu-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(3px);
      z-index: 150;
      display: none;
    }
    .menu-overlay.visible {
      display: block;
    }

    .side-menu {
      position: fixed;
      top: 0;
      left: -300px;
      width: 280px;
      height: 100vh;
      background: rgba(11, 15, 25, 0.98);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-right: 1px solid rgba(255,255,255,0.05);
      z-index: 200;
      padding: 30px 20px;
      transition: left 0.35s cubic-bezier(0.2, 0.9, 0.3, 1);
      box-shadow: 10px 0 50px rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .side-menu.open {
      left: 0;
    }

    .side-menu h2 {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, #22c55e, #86efac);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 40px;
      padding-left: 8px;
      flex-shrink: 0;
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 18px 16px;
      border-radius: 20px;
      font-size: 17px;
      font-weight: 500;
      color: #eee;
      margin-bottom: 8px;
      transition: all 0.2s;
      cursor: pointer;
      border: 1px solid transparent;
      flex-shrink: 0;
    }

    .menu-item:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(34,197,94,0.3);
    }

    .menu-item .icon {
      font-size: 24px;
      width: 32px;
      text-align: center;
    }

    .profile-section {
      margin-top: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 20px;
    }
    #profileUsername {
      font-size: 15px;
      color: #22c55e;
      font-weight: 600;
      margin-left: 48px;
      margin-top: 4px;
      display: block;
      word-break: break-word;
    }

    /* ---------- LEADERBOARD MODAL (gamified) ---------- */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(8px);
      z-index: 250;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.show {
      display: flex;
    }
    .leaderboard-modal {
      background: #0f172a;
      width: 90%;
      max-width: 340px;
      border-radius: 48px;
      padding: 28px 20px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 40px 60px rgba(0,0,0,0.8);
      text-align: center;
    }
    .leaderboard-modal h3 {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .leaderboard-list {
      margin: 20px 0;
    }
    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255,255,255,0.05);
      margin: 8px 0;
      padding: 14px 18px;
      border-radius: 60px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .rank {
      font-size: 20px;
      font-weight: 800;
      width: 40px;
      text-align: left;
    }
    .rank-1 { color: #fbbf24; }  /* gold */
    .rank-2 { color: #94a3b8; }  /* silver */
    .rank-3 { color: #b45309; }  /* bronze */
    .player-info {
      flex: 1;
      text-align: left;
      font-weight: 600;
    }
    .player-stats {
      font-size: 14px;
      color: #94a3b8;
    }
    .modal-close {
      background: #1e293b;
      border: none;
      color: white;
      padding: 14px 30px;
      border-radius: 60px;
      font-size: 18px;
      font-weight: 600;
      margin-top: 16px;
      cursor: pointer;
      width: 100%;
    }

    /* ---------- COLLAPSIBLE BOTTOM RUN CARD ---------- */
    .run-card-container {
      position: fixed;
      bottom: 20px;
      left: 16px;
      right: 16px;
      z-index: 60;
      pointer-events: none;
    }

    .run-card {
      background: rgba(17, 25, 40, 0.9);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-radius: 34px;
      padding: 0;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 20px 40px -8px black;
      pointer-events: auto;
      transition: all 0.3s ease;
    }

    .card-handle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 20px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .handle-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .distance-row {
      display: flex;
      align-items: baseline;
      gap: 6px;
    }
    .distance-number-small {
      font-size: 1.8rem;
      font-weight: 700;
      color: white;
      line-height: 1;
    }
    .distance-unit-small {
      font-size: 1rem;
      color: #64748b;
    }
    .mini-stats {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: #94a3b8;
    }
    .mini-stats span {
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .handle-right {
      font-size: 24px;
      color: #94a3b8;
      transition: transform 0.3s;
    }
    .card-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: 500px;
      padding: 0 20px 22px 20px;
    }
    .run-card.collapsed .card-content {
      max-height: 0;
      padding: 0 20px;
    }
    .run-card.collapsed .handle-right {
      transform: rotate(180deg);
    }

    .runner-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .runner-name {
      font-size: 18px;
      font-weight: 600;
      color: white;
    }
    .runner-name small {
      font-size: 14px;
      font-weight: 400;
      color: #94a3b8;
      margin-left: 4px;
    }
    .runner-status {
      font-size: 13px;
      background: #1e293b;
      padding: 4px 12px;
      border-radius: 40px;
      color: #22c55e;
      font-weight: 500;
    }

    .distance-compact {
      text-align: left;
      margin: 4px 0 8px;
    }
    .distance-number {
      font-size: 3.2rem;
      font-weight: 700;
      line-height: 1;
      letter-spacing: -1px;
      color: white;
    }
    .distance-unit {
      font-size: 1.1rem;
      font-weight: 500;
      color: #64748b;
      margin-left: 6px;
    }

    .location-line {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #94a3b8;
      margin-bottom: 16px;
    }
    .location-line .dot {
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 10px;
      box-shadow: 0 0 8px #22c55e;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      background: rgba(0,0,0,0.25);
      border-radius: 60px;
      padding: 12px 14px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .stat-item {
      text-align: center;
      flex: 1;
    }
    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #94a3b8;
      margin-bottom: 4px;
    }
    .stat-value {
      font-size: 20px;
      font-weight: 700;
      color: white;
    }
    .stat-unit {
      font-size: 10px;
      color: #64748b;
      margin-left: 2px;
    }

    .run-action-btn {
      width: 100%;
      padding: 18px;
      border: none;
      border-radius: 60px;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(95deg, #22c55e, #16a34a);
      color: #0f172a;
      box-shadow: 0 16px 30px rgba(34,197,94,0.5);
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .run-action-btn.running {
      background: linear-gradient(95deg, #ef4444, #b91c1c);
      box-shadow: 0 16px 30px rgba(239,68,68,0.4);
      color: white;
    }
    .run-action-btn:disabled {
      opacity: 0.5;
      box-shadow: none;
    }

    .hint-text {
      text-align: center;
      margin-top: 12px;
      font-size: 12px;
      color: #6b7280;
    }

    /* ---------- TOAST (info style) ---------- */
    .toast {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      backdrop-filter: blur(20px);
      padding: 12px 26px;
      border-radius: 60px;
      font-weight: 500;
      display: none;
      z-index: 300;
      box-shadow: 0 20px 40px black;
      border: 1px solid rgba(255,255,255,0.1);
      color: white;
      font-size: 15px;
      white-space: nowrap;
    }
    .toast.success { background: #166534; }
    .toast.error { background: #7f1d1d; }
    .toast.info { background: #1e293b; }

    #userSelector { display: none; }
  </style>
</head>
<body>

  <div id="map"></div>

  <!-- LEADERBOARD MODAL -->
  <div class="modal-overlay" id="leaderboardModal">
    <div class="leaderboard-modal">
      <h3>üèÜ LEADERBOARD</h3>
      <div id="leaderboardList" class="leaderboard-list"></div>
      <button class="modal-close" id="closeLeaderboardBtn">CLOSE</button>
    </div>
  </div>

  <!-- SIDE MENU OVERLAY -->
  <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>

  <!-- SIDE MENU -->
  <div class="side-menu" id="sideMenu">
    <h2>‚ö° KADAM</h2>
    
    <div class="menu-item" id="menuRunToWin">
      <span class="icon">üèÜ</span> Run to Win
    </div>
    <div class="menu-item" id="menuMyTerritories">
      <span class="icon">üó∫</span> My Territories
    </div>
    <div class="menu-item" id="menuLeaderboard">
      <span class="icon">ü•á</span> Leaderboard
    </div>
    <div class="menu-item" id="menuMyProfile">
      <span class="icon">üë§</span> My Profile
    </div>
    <div class="profile-section">
      <span id="profileUsername">(not logged in)</span>
    </div>
  </div>

  <!-- TOP BAR ‚Äì only hamburger -->
  <div class="top-bar">
    <div class="menu-btn" onclick="toggleMenu()">
      <div></div>
    </div>
  </div>

  <!-- COLLAPSIBLE BOTTOM RUN CARD -->
  <div class="run-card-container">
    <div class="run-card" id="runCard">
      <div class="card-handle" onclick="toggleCardCollapse()">
        <div class="handle-left">
          <div class="distance-row">
            <span class="distance-number-small" id="handleDistance">0.00</span>
            <span class="distance-unit-small">km</span>
          </div>
          <div class="mini-stats" id="miniStats">
            <span>‚è±Ô∏è <span id="handleDuration">00:00</span></span>
            <span>‚ö° <span id="handleSpeed">0.0</span> km/h</span>
          </div>
        </div>
        <div class="handle-right" id="collapseChevron">‚ñº</div>
      </div>
      <div class="card-content" id="cardContent">
        <div class="runner-row">
          <span class="runner-name" id="runnerDisplay">Start <small>runner</small></span>
          <span class="runner-status" id="runStatus">idle</span>
        </div>
        <div class="distance-compact">
          <span class="distance-number" id="distance">0.00</span>
          <span class="distance-unit">km</span>
        </div>
        <div class="location-line">
          <span class="dot"></span>
          <span id="runLocation">acquiring GPS‚Ä¶</span>
        </div>
        <div class="stats-row">
          <div class="stat-item">
            <div class="stat-label">DURATION</div>
            <div class="stat-value" id="duration">00:00</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">LAPS</div>
            <div class="stat-value" id="laps">0</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">SPEED</div>
            <div class="stat-value" id="avgSpeed">0.0</div>
            <span class="stat-unit">km/h</span>
          </div>
        </div>
        <button class="run-action-btn" id="runBtn" onclick="toggleRun()" disabled>
          ‚ñ∂ START RUN
        </button>
        <div class="hint-text" id="runHint">
          üë§ select profile to begin
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="userSelector"></div>

  <script>
    (function() {
      // --------------------------------------------------------------
      // TERRITORY CAPTURE ‚Äì FIXED BUFFER 25m, DETAILED MESSAGES
      // --------------------------------------------------------------
      const API_BASE = 'https://kadamclashbackend.onrender.com';
      const MOVEMENT_THRESHOLD = 5;
      const LAP_RADIUS = 50;
      const TERRITORY_BUFFER = 25; // 25 meters for reliable 70% overlap

      let map;
      let currentPosition = null;
      let watchId = null;
      let isRunning = false;
      let selectedUserId = null;
      let selectedUsername = null;

      let runPath = [];
      let runStartTime = null;
      let runTimer = null;
      let lapCount = 0;
      let lastLapCheckPosition = null;

      let userMarker = null;
      let accuracyCircle = null;
      let pathLayer = L.layerGroup();
      let territoryLayer = L.layerGroup();

      // UI elements
      const runBtn = document.getElementById('runBtn');
      const runCard = document.getElementById('runCard');
      const runnerDisplay = document.getElementById('runnerDisplay');
      const runHint = document.getElementById('runHint');
      const distanceEl = document.getElementById('distance');
      const handleDistance = document.getElementById('handleDistance');
      const handleDuration = document.getElementById('handleDuration');
      const handleSpeed = document.getElementById('handleSpeed');
      const durationEl = document.getElementById('duration');
      const lapsEl = document.getElementById('laps');
      const avgSpeedEl = document.getElementById('avgSpeed');
      const runLocationSpan = document.getElementById('runLocation');
      const runStatusSpan = document.getElementById('runStatus');
      const profileUsernameSpan = document.getElementById('profileUsername');
      const toast = document.getElementById('toast');

      // Leaderboard modal
      const leaderboardModal = document.getElementById('leaderboardModal');
      const leaderboardList = document.getElementById('leaderboardList');
      const closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');

      // Collapse state
      let isCardCollapsed = false;
      window.toggleCardCollapse = function() {
        isCardCollapsed = !isCardCollapsed;
        if (isCardCollapsed) {
          runCard.classList.add('collapsed');
        } else {
          runCard.classList.remove('collapsed');
        }
      };

      // Helper: show toast (with types)
      function showToast(message, type = 'info') {
        toast.className = `toast ${type}`;
        toast.innerHTML = message;
        toast.style.display = 'flex';
        setTimeout(() => { toast.style.display = 'none'; }, 4000);
      }

      // API health ‚Äì only show errors
      let lastOnline = false;
      async function checkAPI() {
        try {
          const res = await fetch(`${API_BASE}/health`);
          const data = await res.json();
          const online = (data.database === 'connected');
          if (!online && lastOnline) {
            showToast('‚ö†Ô∏è DB issue', 'error');
          } else if (!online) {
            showToast('‚ö†Ô∏è DB issue', 'error');
          }
          lastOnline = online;
        } catch {
          if (lastOnline) {
            showToast('‚ùå Server offline', 'error');
          } else {
            showToast('‚ùå Server offline', 'error');
          }
          lastOnline = false;
        }
      }
      checkAPI();
      setInterval(checkAPI, 15000);

      // Update profile UI
      function updateProfileUI() {
        if (selectedUsername) {
          runnerDisplay.innerHTML = `${selectedUsername} <small>runner</small>`;
          profileUsernameSpan.innerText = `@${selectedUsername}`;
          runHint.innerText = 'ready to run';
        } else {
          runnerDisplay.innerHTML = 'Start <small>runner</small>';
          profileUsernameSpan.innerText = '(not logged in)';
        }
      }

      // Menu functions
      window.toggleMenu = function() {
        document.getElementById('sideMenu').classList.toggle('open');
        document.getElementById('menuOverlay').classList.toggle('visible');
      };
      window.closeMenu = function() {
        document.getElementById('sideMenu').classList.remove('open');
        document.getElementById('menuOverlay').classList.remove('visible');
      };

      // Leaderboard function ‚Äì gamified modal
      function showLeaderboard() {
        if (!territoryLayer || !territoryLayer.getLayers().length) {
          leaderboardList.innerHTML = '<div style="padding: 20px; color: #94a3b8;">No territories yet</div>';
          leaderboardModal.classList.add('show');
          return;
        }
        const ownerMap = new Map(); // ownerName -> { count, totalArea }
        territoryLayer.eachLayer(layer => {
          if (layer instanceof L.Polygon) {
            const owner = layer.options.ownerName || 'unknown';
            const area = layer.options.territoryArea || 0;
            if (!ownerMap.has(owner)) {
              ownerMap.set(owner, { count: 0, totalArea: 0 });
            }
            const stats = ownerMap.get(owner);
            stats.count += 1;
            stats.totalArea += area;
          }
        });

        const sorted = Array.from(ownerMap.entries())
          .map(([name, stats]) => ({ name, totalArea: stats.totalArea, count: stats.count }))
          .sort((a,b) => b.totalArea - a.totalArea)
          .slice(0, 10);

        if (sorted.length === 0) {
          leaderboardList.innerHTML = '<div style="padding: 20px; color: #94a3b8;">No territories</div>';
        } else {
          let html = '';
          sorted.forEach((u, idx) => {
            let rankClass = '';
            if (idx === 0) rankClass = 'rank-1';
            else if (idx === 1) rankClass = 'rank-2';
            else if (idx === 2) rankClass = 'rank-3';
            html += `
              <div class="leaderboard-item">
                <span class="rank ${rankClass}">#${idx+1}</span>
                <span class="player-info">${u.name}</span>
                <span class="player-stats">${u.totalArea.toFixed(0)} m¬≤ ¬∑ ${u.count} üó∫Ô∏è</span>
              </div>
            `;
          });
          leaderboardList.innerHTML = html;
        }
        leaderboardModal.classList.add('show');
      }

      // Close leaderboard
      window.closeLeaderboard = function() {
        leaderboardModal.classList.remove('show');
      };
      closeLeaderboardBtn.addEventListener('click', closeLeaderboard);
      // Optional: close on overlay click
      leaderboardModal.addEventListener('click', (e) => {
        if (e.target === leaderboardModal) closeLeaderboard();
      });

      // Sidebar actions
      document.getElementById('menuRunToWin').addEventListener('click', ()=>{
        showToast('üèÜ Run to Win ‚Äì start moving!', 'info');
        closeMenu();
      });
      document.getElementById('menuMyTerritories').addEventListener('click', ()=>{
        if(selectedUserId) {
          loadTerritories();
          showToast('üó∫ Territories refreshed', 'info');
        } else {
          showToast('üë§ Select a profile first', 'error');
        }
        closeMenu();
      });
      document.getElementById('menuLeaderboard').addEventListener('click', ()=>{
        showLeaderboard();
        closeMenu();
      });
      document.getElementById('menuMyProfile').addEventListener('click', ()=>{
        selectRunner();
        closeMenu();
      });

      // Select runner
      window.selectRunner = async function() {
        const name = prompt('Enter your runner name (new or existing):');
        if (!name || !name.trim()) return;
        const trimmed = name.trim();
        try {
          const res = await fetch(`${API_BASE}/api/users`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: trimmed })
          });
          const user = await res.json();
          selectedUserId = user.id || user._id;
          selectedUsername = user.username;

          updateProfileUI();
          runBtn.disabled = false;
          runHint.innerText = 'Ready to run';
          runStatusSpan.innerText = 'ready';
          showToast(`Welcome, ${selectedUsername}!`, 'success');
          loadTerritories();
        } catch (e) {
          showToast('User creation failed', 'error');
        }
      };

      // Generate color from username (hash)
      function stringToColor(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        const hue = Math.abs(hash % 360);
        return `hsl(${hue}, 70%, 55%)`; // bright, distinct
      }

      // Load territories ‚Äì compute area if missing, assign colors
      async function loadTerritories() {
        if (!selectedUserId) return;
        try {
          const res = await fetch(`${API_BASE}/api/territories`);
          const territories = await res.json();
          territoryLayer.clearLayers();
          territories.forEach(t => {
            if (!t.geometry || !t.geometry.coordinates) return;
            const coords = t.geometry.coordinates[0].map(c => [c[1], c[0]]);
            const ownerId = t.ownerId?._id || t.ownerId;
            const isOwn = (ownerId === selectedUserId);
            
            let area = t.area;
            if (!area && t.geometry) {
              try {
                area = turf.area(t.geometry);
              } catch (e) { area = 0; }
            }
            
            const bestTime = t.bestTime ? t.bestTime.toFixed(1) : 'N/A';
            const ownerName = t.ownerId?.username || 'Unknown';
            
            // Color: own = green, others = hash based
            const fillColor = isOwn ? '#22c55e' : stringToColor(ownerName);
            
            const polygon = L.polygon(coords, {
              color: fillColor,
              weight: 4,
              fillColor: fillColor,
              fillOpacity: 0.45,
              interactive: true,
              ownerName: ownerName,
              territoryArea: area || 0
            }).addTo(territoryLayer);
            
            polygon.bindPopup(`
              <b>${isOwn ? 'YOUR' : ownerName}'s TERRITORY</b><br>
              Owner: ${ownerName}<br>
              Area: ${area ? area.toFixed(0) : 'N/A'} m¬≤<br>
              Best lap: ${bestTime} s
            `);
          });
        } catch (e) {
          console.warn('Failed to load territories', e);
        }
      }

      // Map init
      function initMap() {
        map = L.map('map', { zoomControl: false }).setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap'
        }).addTo(map);

        pathLayer.addTo(map);
        territoryLayer.addTo(map);

        if (!navigator.geolocation) {
          runLocationSpan.innerText = '‚ùå GPS not supported';
          return;
        }
        navigator.geolocation.getCurrentPosition(initPosition, handleGeoError, {
          enableHighAccuracy: true,
          timeout: 10000
        });

        watchId = navigator.geolocation.watchPosition(updatePosition, handleGeoError, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      }

      function handleGeoError(err) {
        runLocationSpan.innerText = '‚ùå Location denied';
        showToast('Please enable GPS', 'error');
      }

      function initPosition(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        currentPosition = [latitude, longitude];
        map.setView(currentPosition, 18);

        userMarker = L.marker(currentPosition, {
          icon: L.divIcon({ className: 'user-marker', html: '<div></div>', iconSize: [22,22] })
        }).addTo(map);

        accuracyCircle = L.circle(currentPosition, {
          radius: accuracy,
          color: '#3b82f6',
          fillColor: '#3b82f6',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(map);

        runLocationSpan.innerText = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
      }

      function updatePosition(pos) {
        const { latitude, longitude, accuracy, speed } = pos.coords;
        if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) return;

        const newPos = [latitude, longitude];
        currentPosition = newPos;

        if (userMarker) userMarker.setLatLng(newPos);
        if (accuracyCircle) {
          accuracyCircle.setLatLng(newPos);
          accuracyCircle.setRadius(accuracy);
        }

        const speedKmh = speed ? (speed * 3.6).toFixed(1) : '?';
        runLocationSpan.innerText = `${latitude.toFixed(4)}, ${longitude.toFixed(4)} | ${speedKmh} km/h`;

        if (isRunning) {
          addPointToRun(newPos, speed);
        }
      }

      // Run logic
      function addPointToRun(pos, speedMs) {
        if (!runPath.length) {
          runPath.push({ lat: pos[0], lng: pos[1], timestamp: Date.now(), speed: speedMs || 0 });
          lastLapCheckPosition = pos;
          drawRunPath();
          return;
        }
        const last = runPath[runPath.length-1];
        const lastPos = [last.lat, last.lng];
        const dist = calculateDistance(lastPos, pos);
        if (dist < MOVEMENT_THRESHOLD && (!speedMs || speedMs < 0.5)) return;

        runPath.push({ lat: pos[0], lng: pos[1], timestamp: Date.now(), speed: speedMs || 0 });

        if (runPath.length > 5) {
          const start = [runPath[0].lat, runPath[0].lng];
          const distToStart = calculateDistance(pos, start);
          if (distToStart <= LAP_RADIUS) {
            if (lastLapCheckPosition) {
              const distFromLastLap = calculateDistance(pos, lastLapCheckPosition);
              if (distFromLastLap > LAP_RADIUS * 1.5) {
                lapCount++;
                lapsEl.innerText = lapCount;
                lastLapCheckPosition = pos;
                showToast(`üèÅ Lap ${lapCount}!`, 'info');
              }
            } else {
              lapCount++;
              lapsEl.innerText = lapCount;
              lastLapCheckPosition = pos;
            }
          }
        }
        drawRunPath();
        updateRunStats();
      }

      function drawRunPath() {
        pathLayer.clearLayers();
        if (runPath.length < 2) return;
        const latlngs = runPath.map(p => [p.lat, p.lng]);
        L.polyline(latlngs, { color: '#3b82f6', weight: 5, opacity: 0.8 }).addTo(pathLayer);
        L.circleMarker([runPath[0].lat, runPath[0].lng], { radius: 6, color: '#22c55e', fillColor: '#22c55e', fillOpacity: 1 }).addTo(pathLayer);
        L.circleMarker([runPath[runPath.length-1].lat, runPath[runPath.length-1].lng], { radius: 6, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 1 }).addTo(pathLayer);
      }

      function updateRunStats() {
        if (runPath.length < 2 || !runStartTime) return;
        let totalM = 0;
        for (let i=1; i<runPath.length; i++) {
          totalM += calculateDistance([runPath[i-1].lat, runPath[i-1].lng], [runPath[i].lat, runPath[i].lng]);
        }
        const distKm = totalM / 1000;
        distanceEl.innerText = distKm.toFixed(2);
        handleDistance.innerText = distKm.toFixed(2);
        const secs = Math.floor((Date.now() - runStartTime) / 1000);
        const mins = Math.floor(secs/60);
        const remainingSecs = secs % 60;
        const durationStr = `${mins.toString().padStart(2,'0')}:${remainingSecs.toString().padStart(2,'0')}`;
        durationEl.innerText = durationStr;
        handleDuration.innerText = durationStr;
        const hours = secs / 3600;
        const avg = hours > 0 ? distKm / hours : 0;
        avgSpeedEl.innerText = avg.toFixed(1);
        handleSpeed.innerText = avg.toFixed(1);
      }

      window.toggleRun = function() {
        if (!selectedUserId) {
          showToast('Select a runner first', 'error');
          return;
        }
        if (!isRunning) startRun();
        else stopRun();
      };

      function startRun() {
        if (!currentPosition) {
          showToast('Waiting for GPS', 'error');
          return;
        }
        isRunning = true;
        runStartTime = Date.now();
        runPath = [];
        lapCount = 0;
        lastLapCheckPosition = null;
        pathLayer.clearLayers();
        runBtn.innerText = '‚èπÔ∏è STOP RUN';
        runBtn.classList.add('running');
        runCard.classList.add('running');
        runHint.innerText = 'üèÉ moving ‚Äì claim territory';
        runStatusSpan.innerText = 'running';
        runnerDisplay.innerHTML = `${selectedUsername} <small>running</small>`;
        addPointToRun(currentPosition, 0);
        runTimer = setInterval(() => { if (isRunning) updateRunStats(); }, 1000);
        showToast('Run started!', 'info');
      }

      async function stopRun() {
        isRunning = false;
        clearInterval(runTimer);
        runBtn.innerText = '‚ñ∂ START RUN';
        runBtn.classList.remove('running');
        runCard.classList.remove('running');
        runHint.innerText = 'Processing run...';
        runBtn.disabled = true;

        if (runPath.length < 5) {
          showToast('Run too short (need more movement)', 'error');
          resetRunUI();
          return;
        }

        try {
          const lineCoords = runPath.map(p => [p.lng, p.lat]);
          const line = turf.lineString(lineCoords);
          // Buffer 25m for reliable overlap
          const buffered = turf.buffer(line, TERRITORY_BUFFER, { units: 'meters' });
          if (!buffered || !buffered.geometry) throw new Error('Buffer failed');
          
          // Validate polygon has area
          const area = turf.area(buffered);
          if (area < 1) throw new Error('Buffered area too small');

          const duration = Math.floor((Date.now() - runStartTime) / 1000);
          const totalDistM = runPath.slice(1).reduce((acc, _, i) => {
            return acc + calculateDistance([runPath[i].lat, runPath[i].lng], [runPath[i+1].lat, runPath[i+1].lng]);
          }, 0);
          const avgSpeed = (totalDistM/1000) / (duration/3600);
          const payload = {
            userId: selectedUserId,
            polygon: buffered.geometry,
            duration: duration,
            laps: lapCount || 1,
            avgSpeed: avgSpeed || 0
          };

          console.log('Submitting run:', JSON.stringify(payload, null, 2));

          const res = await fetch(`${API_BASE}/api/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const result = await res.json();
          console.log('Run result:', result);

          // Show detailed message based on result
          if (result.created) {
            showToast('‚ú® New territory created!', 'success');
          } else if (result.captured) {
            // We need to know who was defeated. The backend doesn't send previous owner.
            // We can guess from the territory that was intersected (but we don't know which one).
            // For simplicity, show generic victory.
            showToast('‚öîÔ∏è You captured an enemy territory!', 'success');
          } else {
            // Possibly failed battle ‚Äì we can try to retrieve the territory that was defended
            // For now, generic message.
            showToast('üèÉ Run recorded (no capture)', 'info');
          }

          // Force reload territories to reflect ownership changes
          await loadTerritories();
        } catch (err) {
          showToast('Error: ' + err.message, 'error');
          console.error(err);
        } finally {
          resetRunUI();
        }
      }

      function resetRunUI() {
        runPath = [];
        pathLayer.clearLayers();
        distanceEl.innerText = '0.00';
        handleDistance.innerText = '0.00';
        durationEl.innerText = '00:00';
        handleDuration.innerText = '00:00';
        lapsEl.innerText = '0';
        avgSpeedEl.innerText = '0.0';
        handleSpeed.innerText = '0.0';
        runBtn.disabled = false;
        runHint.innerText = 'Ready';
        runStatusSpan.innerText = 'ready';
        if (selectedUsername) {
          runnerDisplay.innerHTML = `${selectedUsername} <small>runner</small>`;
        } else {
          runnerDisplay.innerHTML = 'Start <small>runner</small>';
        }
      }

      function calculateDistance(p1, p2) {
        const R = 6371e3;
        const œÜ1 = p1[0] * Math.PI / 180;
        const œÜ2 = p2[0] * Math.PI / 180;
        const ŒîœÜ = (p2[0] - p1[0]) * Math.PI / 180;
        const ŒîŒª = (p2[1] - p1[1]) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ/2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      window.addEventListener('beforeunload', () => {
        if (watchId) navigator.geolocation.clearWatch(watchId);
      });

      // Initialize
      initMap();
      updateProfileUI();
    })();
  </script>
</body>
</html>
